// Blob - специальный обьект в котором могут храниться какие то файлы. Это часть файл апи FileApi ----------------------
// // у него есть тип(не обязательно) и с каких то кусков, которые могут быть строками, блобами, буферами
// //MINI Типы - некая страка которая характеризует тот формат данных который передают по сети, в запросе
// let blob = new Blob(['Hi'])
// let blob1 = new Blob(['Hi', blob, new ArrayBuffer(10)], {type:''}/*-не обязательный*/);
//Нужно для того, что б сформировать файлик для скачки клиентом  -----------------------------------------------
//1. СКАЧКА ФАЙЛОВ ==============================================================================
//На кнопку вешаем обработчик onClick далее в функцию OnClickHandler передаем наши сопосбы 1 или 2
// const onClickHandle=async (e)=>{
//     const res = await api.getFile();
//     loadWithUrl(res);
//     //или
//     loadWIthBase64(res);
// }
//1. способ -------------------------------------------------
// // const loadWIthUrl =(content)=>{
//     //1. creat blob
//     const blob = new Blob([content]);
//     //2. создаем какой-то URL и передаем в него blob
//     const url = URL.createObjectURL(blob); //сформировали ссылку по которой можно что-то скачать
//     //3. что бы скачать
//     const a = document.createElement('a');//создаем тег а
//     //Заполняем атрибуты этого тега
//     a.href = url;//Тег будет равен урлу который мы сформировали выше const url = URL.createObjectURL(blob);
//     a.download = 'hello.txt';//Указываем по ссылке что нужно скачать.
//     // 'hello.txt-формат лучше сразу нужный поставить, обычно договор с бекендом'-имя файла
//     a.style = 'dispalay: none;'//Делаем так что б не моргал экран, делаем ссылку невидимой И вставляем ее в body
//     document.body.appendChild(a);
//     //4. имитируем клик по ней
//     a.click();//В этот момент наш файлик начнет скачиваться
//     //5. затем удаляем из DOMa ссылку
//     a.remove();
//     //Важнй момент
//     URL.revokeObjectURL(url);//что бы удалить URL обьект, он сам не удаляется, нужно вручную
// }
//2. способ Base64 ------------------------------------------------------
// // - двоичные данные при помощи 64-ох символов ASCII
// // - не лучший выбор когда фалы для скачивания имеют большой обьем!!! Затрачивается время на декодинк инкодинк
// const loadWIthBase64 = (content) => {
// //1.create blob
//     let blob = new Blob([content]);
//
//     let reader = new FileReader();//Предоставляет обьект, с помощью которого можно читать содержимое файлов
//     reader.readAsDataURL(blob);//Метод который позволяет сформировать url
//     reader.onload = function () {
//         let url = reader.result;//Дается url с закодированным файлом
//         const a = document.createElement('a');
//         a.href = url;
//         a.download = 'hello.avi';
//         a.style = 'display: none;'
//
//         document.body.appendChild(a);
//
//         a.click();
//         a.remove();
//         //В данном случаи url удалять не нужно, то есть делать URL.revokeObjectURL(url);
//     }
// }

// Можно сразу в axios что б он передвал в res уже сразу blob---------------------------------------------------------------------------------
// const api = {
//     getFile() {
//         return axios.get('http://localhost', {responseType: 'blob'}).then(res => res.data);
//         //И вот в res.data уже попадет blob
//     }
// }
// const loadWIthUrl = (blob) => {//теперь сюда будет попадать сразу blob из-за axios
//     //1. creat blob
//     // const blob = new Blob([content]);//То есть уже можно строчку не писать, за нас это сделат axios
// //сразу передается в следующий URL
//     const url = URL.createObjectURL(blob);
// }

//2 ЗАДАЧА. ЗАГРУЗКА ФАЙЛОВ НА БЭКЕНД (раскоминтить целиком)=========================================================
// //Логика для input, нужно повесить обработчик onChange
// const api = {
//     loadFile(formData) {
//         return axios.post('http://localhost', formData)
//     }
// }
//
// const onChangeHandler = async (e) => {
//     //Далее event, обращаемся к currentTarget.files
//     const file = e.currentTarget.files[0];//Если один фалйик то через индекс [0]
//     //Самый простой способ передать прямо в body
//     await api.loadFile(file);
// //Но чаще файлы отправляются так: Есть специальный обьект - creat
//     const formData = new FormData();
//     //Так можно отправлять данные с формы, либо отправлять файлы (попросят formData-ту пришли)---
//     //Для того что бы в обьект что-то отправить пишем:
//     formData.append('file', file);
//     //Если до этого еще какая форма собиралась, то можно дополнительно
//     formData.append('firstName', 'Nik');
//     formData.append('age', 31);
//     //Вот нам нужно то же в body отправить
//     await api.loadFile(formData);
//     //Можно напистаь в одну строчку
//     const data ={}//Те данные что пришли
//     Object.keys(data/*-то что из формы собралось*/).forEach(k=>{
//         //Для каждого ключа мы делаем:
//         formData.append(k, data[k]);
//     })//Таким образом мы превращаем то что собралось из formik или react-hook-form и апендим это в специальный
//     // обьект formData
//     // можно и через event и т. д.--------------
//         //fileReader исп. вроде как редко ------
//     const fileReader = new FileReader();
//     fileReader.readAsText(file, 'ascii');//Не позволит читатб русские символы, для русских нужно UTF-8
//     fileReader.readAsArrayBuffer(file);//Просто получим голый обьект в байтах
//     fileReader.onload = () => {
//     }
//     // -----------------------------------------
// }
//=====================================================================================================================

//GENERATORS =====================================================================================
// function* creatGenerator() {}//Код внутри этой функции выполняется чанками, это позволяет делать по ключевому слову yield
// // если yield вообще нет, это означает все, закончил
//1 -------------------------
// console.log(1);
// console.log(2);
// return 10;
// 2 Можно писать yield---------------------------
// console.log(1)
// console.log(2)
// yield;//Означает типо жди на этой строчке, держись. И когда вызывается метод next код выполняется для первого
// // yield-означает все остановись, дальше не выполняйся и когда вызовится next еще раз,
// // выполнится следующая часть кода до yeild и т. д.
// console.log(3)
// console.log(4)
// yield;// то что записывается после yield попадает в св-в value.
// //Если напишем return то все, мы вышли из функции дальше код не выполняем. next по прежнему можно вызывать,
// // но он будет возвращать value: undefined
// console.log(5)
// console.log(6)
// yield;
// 3---------------------------
// console.log(1);
// console.log(2);
// let res = yield 1;
// console.log('generator', res);//Значение в res мы сможем получить только на втором вызове next
// console.log(1);
// console.log(2);
// yield 2;
// ---------------------------
// ---------------------------
// ---------------------------
// ---------------------------
// }
// const generator = creatGenerator();//Так она не запустит функцию, что бы что-то произошло нужно вызвать метод next
//1 - 2 ---------------------------------------------------------------
// console.log(generator.next())// 1 2 {value:... done:true-1 или false если 2}     | 1 ---- или 2
// console.log(generator.next())// 1 2 {value:... done:false}                       | 2
// console.log(generator.next())// 1 2 {value:... done:false}                       | 2
// console.log(generator.next())// 1 2 {value:... done:true-скажет что мы закончили}| 2
// 3 ---------------------------------------------------------------
// console.log(generator.next());
// console.log(generator.next('hi'));//Только теперь мы получим res=hi. Можно передать только один аргумент,
// если несколько то в виде массива, получается все равно один аргумент
