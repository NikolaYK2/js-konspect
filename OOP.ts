//Принципы ООП =================================================
//1. ФБСТРАКЦИЯ ================================================
// class User{//Какая то абстрактная вещь которая может описать наших пользователей
// }
// const user = new User()//Это уже не абстракция, а конкретный какой-то физический обьект
//2. ИНКАПСУЛЯЦИЯ ==============================================
// //cокрытие деталей
// class User {
//     name: string
//
//     constructor(
//         private firstName: string,//Скрываем детали реализации
//         private lastName: string//От пользователя скрыли что есть вот такие два поля
//     ) {
//         this.name = `${firstName} ${lastName}`//достаем через интерфейс
//     }
//     private validate(firstName:string){
//     }
//     public getName():string{
//         //МОжно работать с сокрытыми св-в(инкапсулированными св-в и т.д.)
//         return this.firstName
//     }
// }//private - Никто кроме этого класса не может работать с приват св-в и методоми
//
// const user = new User('Nik', 'Kev')
// user.name
//3. наследования ==================================================
// class Car{
// }
// class Ford extends Car{//Наследует св-в и методы бати, за исключением приватных
// }
//4. ПОЛИМАРФИЗМ ===================================================
// type Action<T> ={//Тоже абстракция/ Пишем если хотим просто типизировать какой-то обьект
//     type:string,
//     payload: T
// }
//interface +- то же самое ------------------------
// interface Action<T> {//Пишется обычно если работаем с классами, хотя с type можно делать все то же самое
//     type: string,
//     payload: T
// }
//
// interface IEngine {//Иногда в начале названия ставят буку "I' что бы было понятно что это интерфейс
//     model: string,
//     run: () => void
// }    //Описали как выйглядит двигатель и теперь можно создать конкретную реализацию
// class V6 implements IEngine {//implements - реализует все чт оумеет делать двигатель IEngine
// //Теперь нужно обязательно реализавать св-в
// //     constructor(
// //         public model:string,
// //     ) {}
//     //Попроще без конструкторов
//     model:string = 'V6'
//     run(){
//     }
//     //Каждому классу можно сделать какаие-то свои методы
//     myMethod(){}
//     //Самое главное что б этих классах было все то что описано в интерфейсах
// }
// class V8 implements IEngine {//Эти два класса абстрактно могут называться двигателем
//     model:string = 'V8'
//     run(){
//     }
// }
// //Два класса можно назвать разными, за исключением реализации одного и того же интерфейса,
// // как бы работают по одному чертежу
// //как это применяется
// class Car {//эТА ФН ПОЛУЧАЕТСЯ ПОЛИМОРФНАЯ ПОТОМУ ЧТО ОНА умеет работать с разными обьектами
//     //У машины должен быть двигатель
//     //1. Самый простой способ написать ---------
//     // engine = new V6();
//     // // или
//     // // engine = new V8(); - минус такого подхода, что мы завизались на конкретный двигатель
//     // //(на конкретную реализацию чего-то)
//     //2. Способ универсальный ------------------
//     constructor(private engine: IEngine) {//engine: IEngine Называется внедрение зависимости(dependency enjekshan)
//     }
//     runCar(){//Функция с разными обьектами будет работать по разному(полимарфизм)
//         this.engine.run();
//     }
// }
// //1. способ ----------
// // const car = new Car();
// // car.engine.model //V6 или V8
// //2. способ ----------
// const car = new Car(new V8());//Называется внедрение зависимости(dependency enjekshan)
// car.runCar();
// const car2 = new Car(new V6());
// car2.runCar();//Функция одна у двух разных обьектов, но работать будет по разному
// прмиер -------------------------------------------------------------------------------
// class User {//Класс сам по себе является типом в TS
//     showName() {
//     }
// }
//
// class Admin extends User {
//     showName() {
//     }
// }
//
// class SuperAdmin extends User {
// }
//
// function showUserName(user: User) {
//     user.showName()
// }
//
// showUserName(new User())
// showUserName(new Admin())
// showUserName(new SuperAdmin())
// АБСТРАКТНЫЕ КЛАССЫ ----------------------------------------------------------
// abstract class User {
//     //Все что реализуется помечается как abstract / если пишем abstract то реализовать мы должны у наслдеников extends
//     abstract name: string;
//     abstract showName(): void;
//
//     //Дефолтный метод
//     validate() {
//
//     }
// }
//
// class Alex extends User {
//     name = 'Alex'
//     showName(): void {
//     }
// }
// const alex = new Alex();
// alex.validate();
// //Abstractn класс отличается тем, что мы не можем сделать инстанс абстрактного класса
// // new User();

// ПРИНЦИП ПСИГРЕГАЦИИ ИНТЕРФЕЙСОВ ==================================================
// interface Ia {
//     //Много полей
//     a1: number
//     a2: number
//     a3: number
//     a4: number
//     a5: number
//
//     b(): void
// }
// interface Ib {
//     b():void
// }
// function test(/*a:Ia,*/ b:Ib) {//Интерйес большой, передали его функции, а использует она только фн,
//     // принцип псигригации заключается в том, что бы разбить интерйес например на 2
//     // a.b()
//     b.b()//И теперь этой функции передаем только то что она будет исп. / так и разбиваем на куски интерфейс
//     // если это необходимо
// }
//ИНВЕРСИЯ ЗАВИСИМОСТИ ====================================================================
// interface IB{
// }
// class B implements IB{}
// class B1 implements IB{}
//
// class A{//Класс теперь не зависит от конкретной реализации, зависит теперь только от интерфейса
//     constructor(
//         b:IB
//     ){}
// }
// new A(new B())
// new A(new B1())

